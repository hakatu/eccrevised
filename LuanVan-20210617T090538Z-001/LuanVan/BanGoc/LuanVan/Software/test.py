# -*- coding: utf-8 -*-
"""Copy of test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UgSFmxd5Cjqp44JhrLkwyNCZylUCje-o
"""

import matplotlib.pyplot as plt
import csv
import numpy as np
bits = 256
swap = 1
a = 1412
b = 1045645
dummy = (2**bits-swap) & (a^b)
a = a ^ dummy
b = b ^ dummy
print("a=",a)
print("b=",b)

P256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951
x = 4568979
y = pow(x, P256-2, P256) #this is modular inversion
print ("y inv = ", y)

P256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951
num1 = '55df5d5850f47bad82149139979369fe498a9022a412b5e0bedd2cfc21c3ed91'
num2 = '6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296'
a = int(num1,16)
a = a % P256
b = int(num2,16)
b = b % P256
c = (a*b) % P256
print ("a =",a)
print ("b =",b)
print ("c = ",c)

P256 = 115792089210356248762697446949407573530086143415290314195533631308867097853951
p = P256
#x2 = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
#y2 = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
#z2 = 1

#x2 = 0xec88440c8b00a9e572bf1bceb7d0c5906bd65990a9b7081130bd72e2c136ca0
#y2 = 0x3f43881dcc61766ffe07171330863c080b4422e506909bb9e6642bdcfd959f29
#z2 = 0x22d834ac5ce2e092fbe5330eefc21fa45f5a1229b48c72ae01cc6821f1c03cf9

x2 = 0x96bc12c37037057f6594d8106f80ffb51e4966280588daadeb66a01164bd41cb
y2 = 0xaa8b16e4b810c0a81887423799d8e7d2981c8d8bd3023b736a66d026b1dfbd79
z2 = 0x86f0848bcf9cb2525afb2d38689cddbf749320aaae55e7012b3507c948d757f5

x1 = 0x9a978f59acd1b5ad570e7d52dcfcde43804b42274f61ddcf1e7d848391d6c70f
y1 = 0x4126885e7f786af905338238e5346d5fe77fc46388668bd0fd59be3190d2f5d1
z1 = 0x9fc685c5fc34ff371dcfd694f81f3c2c579c66aed662bd9d976c80d06f7ea3ea

#x1 = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
#y1 = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
#z1 = 1

#st0 = 3*pow(x1,2,p) %p
#st1= pow(y1,2,p) %p
#st2 = st1*x1 %p

#m = (3*pow(x1,2,p)-3*pow(z1,4,p)) % p
#t = pow(y1,4,p)
#s = (4*x1*pow(y1,2,p)) %p
#x = (pow(m,2,p) - 2*s) %p
#y = (m*(s - x) -8*t) %p
#z = 2*y1*z1 %p
#z1 = pow(z, P256-2, P256) #this is modular inversion
#xk = z1*x %p


#print("m =  ", hex(m))
#print("t =  ", hex(t))
#print("s =  ", hex(s))
#print("st0 =  ", hex(st0))
#print("st1 =  ", hex(st1))
#print("st2 =  ", hex(st2))
#print("x =  ", hex(x))
#print("y =  ", hex(y))
#print("z =  ", hex(z))
#print("z1 =  ", hex(z1))
#print("xk =  ", hex(xk))

y22 = (0 - y2) %p
s1 = (y1*pow(z2,3,p)) %p
s2 = (y2*pow(z1,3,p)) %p
u1 = (x1*pow(z2,2,p)) %p
u2 = (x2*pow(z1,2,p)) %p
h = (u1 - u2) %p
r = (s1-s2) %p
g = pow(h,3,p)
v = (u1*pow(h,2,p)) %p
x3 = (pow(r,2,p) - 2*v + g) %p
y3 = (r*(v-x3) - s1*g) %p
z3 = z1*z2*h %p

temp = (2*v) %p
#e= 0xA41A41A12A799548211C410C65D8133AFDE34D28BDD542E4B680CF2899C8A8C4
#d= 0xC477F9F65C22CCE20657FAA5B2D1D8122336F851A508A1ED04E479C34985BF96 
#x = 0x2B42F576D07F4165FF65D1F3B1500F81E44C316F1F0B3EF57325B69ACA46104F
#n = 115792089210356248762697446949407573529996955224135760342422259061068512044369
#k = 0x7A1A7E52797FC8CAAA435D2A4DACE39158504BF204FBE19F14DBB427FAEE50AE
#signr = x %n
#signs = (pow(k, n-2, n)*(e+d*signr)) %n
#t1 = d*signr %n
#t2 = (e+d*signr) %n
#t3 = pow(k, n-2, n)

print("y22 =  ", hex(y22))
print("s1 =  ", hex(s1))
print("s2 =  ", hex(s2))
print("u1 =  ", hex(u1))
print("u2 =  ", hex(u2))
print("h =  ", hex(h))
print("r =  ", hex(r))
print("g =  ", hex(g))
print("v =  ", hex(v))
print("x3 =  ", hex(x3))
print("y3 =  ", hex(y3))
print("z3 =  ", hex(z3))
print("temp =  ", hex(temp))
#print("signr =  ", hex(signr))
#print("signs =  ", hex(signs))
#print("t1 =  ", hex(t1))
#print("t2 =  ", hex(t2))
#print("t3 =  ", hex(t3))

(swap = 0
bits = 255
k = 990
for t in range(bits-1,-1,-1):
  k_t = (k >> t) & 1
  swap ^= k_t
  swaptemp = swap
  swap = k_t
  print("swap1 = ",swaptemp,"swap2 = ",swap)
print("swapfinal = ",swap)

bits = 255
k = 5
for t in range(bits-1,-1,-1):
  k_t = (k >> t) & 1
  print ("k_t=",k_t)

p25519 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed
p448 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff

# decode little endian encoded byte array to integer
def decodeLittleEndian(b, bits = 255):
  return sum([b[i] << 8*i for i in range(int((bits+7)/8))])

# decode an incoming byte array
def decodeUCoordinate(u, bits = 255):
  u_list = [b for b in u]
  # Ignore any unused bits.
  if bits % 8:
    u_list[-1] &= (1<<(bits%8))-1
  return decodeLittleEndian(u_list, bits)

# return string
def encodeUCoordinate(u, bits = 255, p = p25519):
  u = u % p
  return ''.join([chr((u >> 8*i) & 0xff) for i in range(int((bits+7)/8))])

# return bytes
def encodeUCoordinateBytes(u, bits = 255, p = p25519):
  u = u % p
  r = []
  for i in range(int((bits+7)/8)):
    r.append((u >> 8*i) & 0xff)
  return r

# helper function to print byte arrays
def printBytes(s):
  return "".join("{:02x}".format(c) for c in s)

# decode incoming scalars (byte arrays) into an integer (25519)
def decodeScalar25519(k):
  k_list = [b for b in k]
  k_list[0] = int(k_list[0]) & 248
  k_list[31] = int(k_list[31]) & 127
  k_list[31] = int(k_list[31]) | 64
  return decodeLittleEndian(k_list, 255)

# decode incoming scalars (int) into an integer (25519)
def decodeScalar25519int(k):
  k = k & 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8
  k = k | 0x4000000000000000000000000000000000000000000000000000000000000000
  return k

# decode incoming scalars (byte arrays) into an integer (448)
def decodeScalar448(k):
  k_list = [b for b in k]
  k_list[0] = int(k_list[0]) & 252
  k_list[55] = int(k_list[55]) | 128
  return decodeLittleEndian(k_list, 448)

# conditional swap
def cswap(swap, a, b, bits = 255):
  dummy = (2**bits-swap) & (a^b)
  a = a ^ dummy
  b = b ^ dummy
  return (a, b)

def multiply(u, k, p = p25519, a24 = 121665, bits = 255):
  x_2 = 1
  z_2 = 0

  x_3 = u
  z_3 = 1
  a = x_2 ^ x_3
  print(hex(a))
  swap = 0
  print ("init x_2",hex(x_2))
  print ("init z_2",z_2)
  print ("init x_3",hex(x_3))
  print ("init z_3",z_3)
  print ("init swap",swap)
  print ("init u",hex(u))
  print ("init k",hex(k))
  print ("init a24",hex(a24))
  for t in range(bits-1,-1,-1):#fixing to debug, used to be -1
    print ("at t = ",t)
    k_t = (k >> t) & 1
    print ("k_t = ",k_t)
    swap ^= k_t
    print ("1st swap = ",swap)
    print ("before 1st swap, x_2 = ",x_2)
    print ("before 1st swap, x_3 = ",x_3)
    (x_2, x_3) = cswap(swap, x_2, x_3, bits)
    print ("after 1st swap, x_2 = ",x_2)
    print ("after 1st swap, x_3 = ",x_3)
    print ("before 1st swap, z_2 = ",z_2)
    print ("before 1st swap, z_3 = ",z_3)
    (z_2, z_3) = cswap(swap, z_2, z_3, bits)
    print ("after 1st swap, z_2 = ",z_2)
    print ("after 1st swap, z_3 = ",z_3)
    swap = k_t
    print ("2nd swap = ",swap)

    A = (x_2 + z_2) % p
    print ("A result",A)
    AA = pow(A, 2, p)
    print ("AA result",AA)
    B = (x_2 - z_2) % p
    print ("B result",B)
    BB = pow(B, 2, p)
    print ("BB result",BB)
    E = (AA - BB) % p
    print ("E result",E)
    x_2 = (AA * BB) % p
    print ("after first math, x_2 result",x_2)
    z_2 = (E * (AA + (a24 * E))) %p
    print ("after first math, z_2 result",z_2)

    C = (x_3 + z_3) % p
    print ("C result",C)
    D = (x_3 - z_3) % p
    print ("D result",D)
    CB = (C * B) % p
    print ("CB result",CB)
    DA = (D * A) % p
    print ("DA result",DA)
    x_3 = pow(DA + CB, 2, p)
    print ("after second math, x_3 result",x_3)
    DACB2 = pow(DA - CB, 2, p)
    print ("DACB2 result",DACB2)
    z_3 = (u * DACB2) % p
    print ("after second math, z_3 result",z_3)

  print ("before 1st swap, x_2 = ",x_2)
  print ("before 1st swap, x_3 = ",x_3)
  (x_2, x_3) = cswap(0, x_2, x_3, bits)
  print ("after 1st swap, x_2 = ",x_2)
  print ("after 1st swap, x_3 = ",x_3)
  print ("before 1st swap, z_2 = ",z_2)
  print ("before 1st swap, z_3 = ",z_3)
  (z_2, z_3) = cswap(0, z_2, z_3, bits)
  print ("after 1st swap, z_2 = ",z_2)
  print ("after 1st swap, z_3 = ",z_3)
  r = (x_2 * pow(z_2, p - 2, p)) % p # the exponent is modinv
  return r

#knew=decodeScalar25519(k.to_bytes(32, 'little'))
#print ("khex = ", hex(knew))
sIb = bytes([0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
bits = 255
p = p25519
expected = bytes([0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc, 0xa1, 0x35, 0x0b,
              0x3e, 0x2b, 0xb7, 0x27, 0x9f, 0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85,
              0x4b, 0x78, 0x3c, 0x60, 0xe8, 0x03, 0x11, 0xae, 0x30, 0x79])
k =decodeScalar25519(sIb)
#X_G = 0x4c1cabd0a603a9103b35b326ec2466727c5fb124a4c19435db3030586768dbe6
X_G = decodeUCoordinate(sIb)
r = multiply(X_G, k, p = p25519, a24 = 121665, bits = 255)
myResultb = encodeUCoordinate(r, bits, p)
myResultbString = "".join("{:02x}".format(ord(c)) for c in myResultb)
rString = decodeUCoordinate(expected, bits)
print ("ket qua = ", hex(rString))

def testDecodeScalar(s, expected, bits = 255):
  if bits == 255:
    mys = decodeScalar25519(s)
  else:
    mys = decodeScalar448(s)
  if expected == mys:
    print(" >>> decodeScalar is working")
  else:
    print(" >>> decodeScalar is NOT working")
    print("Input    s: "+printBytes(s))
    print("Decoded  s: "+str(hex(mys)))
    print("Expected s: "+str(hex(expected)))

def testDecodeUCoordinate(u, expected, bits = 255):
  myu = decodeUCoordinate(u, bits)
  if expected == myu:
    print(" >>> decodeUCoordinate is working")
  else:
    print(" >>> decodeUCoordinate is NOT working")
    print("Input    u: "+printBytes(u))
    print("Decoded  u: "+str(hex(myu)))
    print("Expected u: "+str(hex(expected)))

def decodeScalar(s, bits = 255):
  if bits == 255:
    return decodeScalar25519(s)
  else:
    return decodeScalar448(s)

def getCurveParameters(bits = 255):
  if bits == 255:
    return ("Curve25519", p25519, 121665)
  else:
    return ("Curve448", p448, 39081)

def testMultiply(u, s, expected, bits = 255, iterations = 1):
  (curve, p, a24) = getCurveParameters(bits)
  ud = u
  sd = s
  for i in range(0,iterations):
    myResult = multiply(decodeUCoordinate(ud, bits), decodeScalar(sd, bits), p, a24, bits)
    ud = sd
    sd = encodeUCoordinateBytes(myResult, bits, p)
  myResultb = encodeUCoordinate(myResult, bits, p)
  myResultbString = "".join("{:02x}".format(ord(c)) for c in myResultb)
  rString = decodeUCoordinate(expected, bits)
  if rString == myResult and myResultbString == printBytes(expected):
    print(" >>> " + curve + " is working")
  else:
    print(" >>> " + curve + " is NOT working")
    print("result  : "+myResultbString)
    print("expected: "+printBytes(expected))
    print("result  : "+str(hex(myResult)))
    print("expected: "+str(hex(rString)))

# TEST 0 - Encoding/Decoding
print("\n ---- TEST 0 - Encoding/Decoding ----\n")

print(" --- 25519 --- ")
testDecodeScalar(s1b, s1)
testDecodeScalar(s2b, s2)
testDecodeUCoordinate(u1b, u1)
testDecodeUCoordinate(u2b, u2)

# NOTE: Curve25519 is not surjective, this encoding works because the most
#       significant bit is 0, the same does not hold in general, which hence
#       does not encode to the expected byte array
myu1b = encodeUCoordinate(u1)
myu1bString = "".join("{:02x}".format(ord(c)) for c in myu1b)
if "".join("{:02x}".format(c) for c in u1b) == myu1bString:
  print(" >>> encodeUCoordinate is working")
else:
  print(" >>> encodeUCoordinate is NOT working")
  print("Input  u1: "+str(hex(u1)))
  print("Encoded u1b: "+myu1bString)
  print("Expected   : "+"".join("{:02x}".format(c) for c in u1b))

print("\n --- 448 --- ")
testDecodeScalar(s1448b, s1448, 448)
testDecodeScalar(s2448b, s2448, 448)
testDecodeUCoordinate(u1448b, u1448, 448)
testDecodeUCoordinate(u2448b, u2448, 448)

# TEST 1 - Values
print("\n ---- TEST 1 - Values ----\n")

testMultiply(u1b, s1b, r1b)
testMultiply(u2b, s2b, r2b)

testMultiply(u1448b, s1448b, r1448b, 448)
testMultiply(u2448b, s2448b, r2448b, 448)

# TEST 2 - Iterations
print("\n ---- TEST 2 - Iterations ----\n")

testMultiply(uIb, sIb, rI1b)
testMultiply(uIb, sIb, rI1000b, 255, 1000)
# 1,000,000 Iterations (you probably don't want to run this, it takes a while)
# testMultiply(uIb, sIb, rI1000000b, 255, 1000000)

testMultiply(uI448b, sI448b, rI1448b, 448)
testMultiply(uI448b, sI448b, rI1000448b, 448, 1000)
# 1,000,000 Iterations (you probably don't want to run this, it takes a while)
# testMultiply(uI448b, sI448b, rI1000000448b, 448, 1000000)

# TEST 1 DATA
s1bI = 0xa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4
s1b = bytes([0xa5, 0x46, 0xe3, 0x6b, 0xf0, 0x52, 0x7c, 0x9d, 0x3b, 0x16, 0x15,
             0x4b, 0x82, 0x46, 0x5e, 0xdd, 0x62, 0x14, 0x4c, 0x0a, 0xc1, 0xfc,
             0x5a, 0x18, 0x50, 0x6a, 0x22, 0x44, 0xba, 0x44, 0x9a, 0xc4])
s1 = 0x449a44ba44226a50185afcc10a4c1462dd5e46824b15163b9d7c52f06be346a0
u1bI = 0xe6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c
u1b = bytes([0xe6, 0xdb, 0x68, 0x67, 0x58, 0x30, 0x30, 0xdb, 0x35, 0x94, 0xc1,
            0xa4, 0x24, 0xb1, 0x5f, 0x7c, 0x72, 0x66, 0x24, 0xec, 0x26, 0xb3,
            0x35, 0x3b, 0x10, 0xa9, 0x03, 0xa6, 0xd0, 0xab, 0x1c, 0x4c])
u1 = 0x4c1cabd0a603a9103b35b326ec2466727c5fb124a4c19435db3030586768dbe6
r1bI = 0xc3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552
r1b = bytes([0xc3, 0xda, 0x55, 0x37, 0x9d, 0xe9, 0xc6, 0x90, 0x8e, 0x94, 0xea,
             0x4d, 0xf2, 0x8d, 0x08, 0x4f, 0x32, 0xec, 0xcf, 0x03, 0x49, 0x1c,
             0x71, 0xf7, 0x54, 0xb4, 0x07, 0x55, 0x77, 0xa2, 0x85, 0x52])

s2bI = 0x4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d
s2b = bytes([0x4b, 0x66, 0xe9, 0xd4, 0xd1, 0xb4, 0x67, 0x3c, 0x5a, 0xd2, 0x26,
             0x91, 0x95, 0x7d, 0x6a, 0xf5, 0xc1, 0x1b, 0x64, 0x21, 0xe0, 0xea,
             0x01, 0xd4, 0x2c, 0xa4, 0x16, 0x9e, 0x79, 0x18, 0xba, 0x0d])
s2 = 0x4dba18799e16a42cd401eae021641bc1f56a7d959126d25a3c67b4d1d4e96648
u2bI = 0xe5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493
u2b = bytes([0xe5, 0x21, 0x0f, 0x12, 0x78, 0x68, 0x11, 0xd3, 0xf4, 0xb7, 0x95,
             0x9d, 0x05, 0x38, 0xae, 0x2c, 0x31, 0xdb, 0xe7, 0x10, 0x6f, 0xc0,
             0x3c, 0x3e, 0xfc, 0x4c, 0xd5, 0x49, 0xc7, 0x15, 0xa4, 0x93])
u2 = 0x13a415c749d54cfc3e3cc06f10e7db312cae38059d95b7f4d3116878120f21e5
r2bI = 0x95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957
r2b = bytes([0x95, 0xcb, 0xde, 0x94, 0x76, 0xe8, 0x90, 0x7d, 0x7a, 0xad, 0xe4,
             0x5c, 0xb4, 0xb8, 0x73, 0xf8, 0x8b, 0x59, 0x5a, 0x68, 0x79, 0x9f,
             0xa1, 0x52, 0xe6, 0xf8, 0xf7, 0x64, 0x7a, 0xac, 0x79, 0x57])

s1448b = bytes([0x3d, 0x26, 0x2f, 0xdd, 0xf9, 0xec, 0x8e, 0x88, 0x49, 0x52, 0x66,
                0xfe, 0xa1, 0x9a, 0x34, 0xd2, 0x88, 0x82, 0xac, 0xef, 0x04, 0x51,
                0x04, 0xd0, 0xd1, 0xaa, 0xe1, 0x21, 0x70, 0x0a, 0x77, 0x9c, 0x98,
                0x4c, 0x24, 0xf8, 0xcd, 0xd7, 0x8f, 0xbf, 0xf4, 0x49, 0x43, 0xeb,
                0xa3, 0x68, 0xf5, 0x4b, 0x29, 0x25, 0x9a, 0x4f, 0x1c, 0x60, 0x0a,
                0xd3])
s1448 = 0xd30a601c4f9a25294bf568a3eb4349f4bf8fd7cdf8244c989c770a7021e1aad1d0045104efac8288d2349aa1fe665249888eecf9dd2f263c
u1448b = bytes([0x06, 0xfc, 0xe6, 0x40, 0xfa, 0x34, 0x87, 0xbf, 0xda, 0x5f, 0x6c,
                0xf2, 0xd5, 0x26, 0x3f, 0x8a, 0xad, 0x88, 0x33, 0x4c, 0xbd, 0x07,
                0x43, 0x7f, 0x02, 0x0f, 0x08, 0xf9, 0x81, 0x4d, 0xc0, 0x31, 0xdd,
                0xbd, 0xc3, 0x8c, 0x19, 0xc6, 0xda, 0x25, 0x83, 0xfa, 0x54, 0x29,
                0xdb, 0x94, 0xad, 0xa1, 0x8a, 0xa7, 0xa7, 0xfb, 0x4e, 0xf8, 0xa0,
                0x86])
u1448 = 0x86a0f84efba7a78aa1ad94db2954fa8325dac6198cc3bddd31c04d81f9080f027f4307bd4c3388ad8a3f26d5f26c5fdabf8734fa40e6fc06
r1448b = bytes([0xce, 0x3e, 0x4f, 0xf9, 0x5a, 0x60, 0xdc, 0x66, 0x97, 0xda, 0x1d,
                0xb1, 0xd8, 0x5e, 0x6a, 0xfb, 0xdf, 0x79, 0xb5, 0x0a, 0x24, 0x12,
                0xd7, 0x54, 0x6d, 0x5f, 0x23, 0x9f, 0xe1, 0x4f, 0xba, 0xad, 0xeb,
                0x44, 0x5f, 0xc6, 0x6a, 0x01, 0xb0, 0x77, 0x9d, 0x98, 0x22, 0x39,
                0x61, 0x11, 0x1e, 0x21, 0x76, 0x62, 0x82, 0xf7, 0x3d, 0xd9, 0x6b,
                0x6f])

s2448b = bytes([0x20, 0x3d, 0x49, 0x44, 0x28, 0xb8, 0x39, 0x93, 0x52, 0x66, 0x5d,
                0xdc, 0xa4, 0x2f, 0x9d, 0xe8, 0xfe, 0xf6, 0x00, 0x90, 0x8e, 0x0d,
                0x46, 0x1c, 0xb0, 0x21, 0xf8, 0xc5, 0x38, 0x34, 0x5d, 0xd7, 0x7c,
                0x3e, 0x48, 0x06, 0xe2, 0x5f, 0x46, 0xd3, 0x31, 0x5c, 0x44, 0xe0,
                0xa5, 0xb4, 0x37, 0x12, 0x82, 0xdd, 0x2c, 0x8d, 0x5b, 0xe3, 0x09,
                0x5f])
s2448 = 0xdf09e35b8d2cdd821237b4a5e0445c31d3465fe206483e7cd75d3438c5f821b01c460d8e9000f6fee89d2fa4dc5d66529339b82844493d20
u2448b = bytes([0x0f, 0xbc, 0xc2, 0xf9, 0x93, 0xcd, 0x56, 0xd3, 0x30, 0x5b, 0x0b,
                0x7d, 0x9e, 0x55, 0xd4, 0xc1, 0xa8, 0xfb, 0x5d, 0xbb, 0x52, 0xf8,
                0xe9, 0xa1, 0xe9, 0xb6, 0x20, 0x1b, 0x16, 0x5d, 0x01, 0x58, 0x94,
                0xe5, 0x6c, 0x4d, 0x35, 0x70, 0xbe, 0xe5, 0x2f, 0xe2, 0x05, 0xe2,
                0x8a, 0x78, 0xb9, 0x1c, 0xdf, 0xbd, 0xe7, 0x1c, 0xe8, 0xd1, 0x57,
                0xdb])
u2448 = 0xdb57d1e81ce7bddf1cb9788ae205e22fe5be70354d6ce59458015d161b20b6e9a1e9f852bb5dfba8c1d4559e7d0b5b30d356cd93f9c2bc0f
r2448b = bytes([0x88, 0x4a, 0x02, 0x57, 0x62, 0x39, 0xff, 0x7a, 0x2f, 0x2f, 0x63,
                0xb2, 0xdb, 0x6a, 0x9f, 0xf3, 0x70, 0x47, 0xac, 0x13, 0x56, 0x8e,
                0x1e, 0x30, 0xfe, 0x63, 0xc4, 0xa7, 0xad, 0x1b, 0x3e, 0xe3, 0xa5,
                0x70, 0x0d, 0xf3, 0x43, 0x21, 0xd6, 0x20, 0x77, 0xe6, 0x36, 0x33,
                0xc5, 0x75, 0xc1, 0xc9, 0x54, 0x51, 0x4e, 0x99, 0xda, 0x7c, 0x17,
                0x9d])

# TEST 2 DATA
sIbI = 0x0900000000000000000000000000000000000000000000000000000000000000
sIb = bytes([0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
uIbI = 0x0900000000000000000000000000000000000000000000000000000000000000
uIb = bytes([0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])

rI1bI = 0x422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079
rI1b = bytes([0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc, 0xa1, 0x35, 0x0b,
              0x3e, 0x2b, 0xb7, 0x27, 0x9f, 0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85,
              0x4b, 0x78, 0x3c, 0x60, 0xe8, 0x03, 0x11, 0xae, 0x30, 0x79])
rI1000bI = 0x684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51
rI1000b = bytes([0x68, 0x4c, 0xf5, 0x9b, 0xa8, 0x33, 0x09, 0x55, 0x28, 0x00,
                 0xef, 0x56, 0x6f, 0x2f, 0x4d, 0x3c, 0x1c, 0x38, 0x87, 0xc4,
                 0x93, 0x60, 0xe3, 0x87, 0x5f, 0x2e, 0xb9, 0x4d, 0x99, 0x53,
                 0x2c, 0x51])
rI1000000bI = 0x7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424
rI1000000b = bytes([0x7c, 0x39, 0x11, 0xe0, 0xab, 0x25, 0x86, 0xfd, 0x86, 0x44,
                    0x97, 0x29, 0x7e, 0x57, 0x5e, 0x6f, 0x3b, 0xc6, 0x01, 0xc0,
                    0x88, 0x3c, 0x30, 0xdf, 0x5f, 0x4d, 0xd2, 0xd2, 0x4f, 0x66,
                    0x54, 0x24])

sI448b = bytes([0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
uI448b = bytes([0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00])

rI1448b = bytes([0x3f, 0x48, 0x2c, 0x8a, 0x9f, 0x19, 0xb0, 0x1e, 0x6c, 0x46,
                 0xee, 0x97, 0x11, 0xd9, 0xdc, 0x14, 0xfd, 0x4b, 0xf6, 0x7a,
                 0xf3, 0x07, 0x65, 0xc2, 0xae, 0x2b, 0x84, 0x6a, 0x4d, 0x23,
                 0xa8, 0xcd, 0x0d, 0xb8, 0x97, 0x08, 0x62, 0x39, 0x49, 0x2c,
                 0xaf, 0x35, 0x0b, 0x51, 0xf8, 0x33, 0x86, 0x8b, 0x9b, 0xc2,
                 0xb3, 0xbc, 0xa9, 0xcf, 0x41, 0x13])
rI1000448b = bytes([0xaa, 0x3b, 0x47, 0x49, 0xd5, 0x5b, 0x9d, 0xaf, 0x1e, 0x5b,
                    0x00, 0x28, 0x88, 0x26, 0xc4, 0x67, 0x27, 0x4c, 0xe3, 0xeb,
                    0xbd, 0xd5, 0xc1, 0x7b, 0x97, 0x5e, 0x09, 0xd4, 0xaf, 0x6c,
                    0x67, 0xcf, 0x10, 0xd0, 0x87, 0x20, 0x2d, 0xb8, 0x82, 0x86,
                    0xe2, 0xb7, 0x9f, 0xce, 0xea, 0x3e, 0xc3, 0x53, 0xef, 0x54,
                    0xfa, 0xa2, 0x6e, 0x21, 0x9f, 0x38])
rI1000000448b = bytes([0x07, 0x7f, 0x45, 0x36, 0x81, 0xca, 0xca, 0x36, 0x93,
                       0x19, 0x84, 0x20, 0xbb, 0xe5, 0x15, 0xca, 0xe0, 0x00,
                       0x24, 0x72, 0x51, 0x9b, 0x3e, 0x67, 0x66, 0x1a, 0x7e,
                       0x89, 0xca, 0xb9, 0x46, 0x95, 0xc8, 0xf4, 0xbc, 0xd6,
                       0x6e, 0x61, 0xb9, 0xb9, 0xc9, 0x46, 0xda, 0x8d, 0x52,
                       0x4d, 0xe3, 0xd6, 0x9b, 0xd9, 0xd9, 0xd6, 0x6b, 0x99,
0x7e, 0x37])

import matplotlib.pyplot as plt
import csv
import numpy as np

with open("example.txt","r") as file: 
    text=file.readlines() 
keyword = 4
replacement = 5
i=0 
while i < len(text): 
    if keyword in text[i]: 
        text[i]=text[i].replace(keywork,replacement) 
with open("file","w") as file: 
    file.writelines(text)

import pandas as pd
# Read in data and examine first 10 rows
flights = pd.read_csv('example.txt')
flights.head(10)

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Read in data and examine first 10 rows
flights = pd.read_csv('example.txt')
flights.head(10)

# matplotlib histogram
plt.hist(flights['arr_delay'], color = 'blue', edgecolor = 'black',
         bins = int(180/5))

# seaborn histogram
sns.distplot(flights['arr_delay'], hist=True, kde=False, 
             bins=int(180/5), color = 'blue',
             hist_kws={'edgecolor':'black'})
# Add labels
plt.title('Histogram of Arrival Delays')
plt.xlabel('Delay (min)')
plt.ylabel('Flights')

from google.colab import drive
# connect to google drive
drive.mount('/content/gdrive')

# %cd '/content/gdrive/My Drive/LuanVan/Colab/dataset'
!pwd